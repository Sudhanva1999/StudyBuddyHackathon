## Hash Table Performance: Size and Collision Handling

### Introduction

This lecture explores the impact of hash table size on performance, focusing on collision handling techniques. We'll revisit open addressing with linear probing and chaining, analyzing their performance characteristics and trade-offs.  The lecture also touches upon the relationship between these techniques and the choice of hash function (covered in the next lecture).  Finally, we'll compare hash table performance with binary search trees, highlighting the strengths and weaknesses of each data structure.

### Key Concepts

* **Collision Handling:** When two or more keys hash to the same index in a hash table, a collision occurs. Two primary methods for resolving collisions are:

    * **Open Addressing (Linear Probing):**  If a collision occurs, the algorithm probes the next available slot in the hash table (using a linear increment). This continues until an empty slot is found.

    * **Chaining (Separate Chaining):** Each index in the hash table points to a linked list (or other data structure).  All keys hashing to the same index are stored in that list.

* **Load Factor (λ):**  A critical metric for hash table performance. It is defined as:

    λ = Number of elements in the hash table / Size of the hash table

    * For open addressing, λ cannot exceed 1.
    * For chaining, λ can be greater than 1.

* **Expected Number of Comparisons:** The average number of probes (or comparisons) needed to find an element (or determine its absence) in the hash table.  This is directly affected by the load factor.

### Performance Analysis

* **Open Addressing (Linear Probing):**

    * As the load factor approaches 1, performance degrades significantly.  The expected number of comparisons approaches linear time (O(n)).
    * An approximate formula for the expected number of comparisons for a successful search is:

        (1 + 1 / (1 - λ)) / 2

* **Chaining (Separate Chaining):**

    * Performance is less sensitive to a high load factor compared to open addressing.
    * The expected number of comparisons for a successful search is approximately:

        1 + λ / 2

    *  This assumes a uniform distribution of keys across the hash table indices.

* **Comparison Table (Approximate Values):**

| Load Factor (λ) | Open Addressing (Expected Comparisons) | Chaining (Expected Comparisons) |
|---|---|---|
| 0 | 1 | 1 |
| 0.5 | 1.5 | 1.25 |
| 0.75 | 2.5 | 1.375 |
| 0.9 | 5.5 | 1.45 |
| → 1 | → ∞ | → 1 + λ/2 |

* **Comparison with Binary Search Trees:**

    * Balanced binary search trees offer logarithmic time complexity (O(log n)) for search, insertion, and deletion.
    * Hash tables with a good load factor can outperform binary search trees, especially for smaller datasets.  However, as the load factor increases in open addressing, hash table performance degrades.
    * Binary search trees require more storage due to pointers/references for left and right children (and potentially a parent node).  Open addressing with linear probing is more space-efficient when the load factor is reasonable. Chaining requires additional space for the linked lists, impacting its space efficiency compared to open addressing.


### Example and Exercise

* **Scenario:**  Store 60,000 items and maintain an average of 2.5 comparisons per search.

* **Open Addressing (Linear Probing):**

    * To achieve 2.5 comparisons, the load factor should be approximately 0.75.
    * Hash Table Size = 60,000 / 0.75 = 80,000

* **Chaining (Separate Chaining):**

    * To achieve 2.5 comparisons:

        2.5 = 1 + λ / 2
        λ = 3

    * Hash Table Size = 60,000 / 3 = 20,000 (initial array size)

* **Storage Comparison:** While chaining appears to require a smaller hash table, it actually uses more memory overall.

    * **Open Addressing:** 80,000 references (approximately).
    * **Chaining:**  20,000 references for the hash table + (60,000 * 2) = 120,000 references for the linked list elements (assuming singly linked lists, requiring one "next" pointer) = 140,000 total references.


### Summary

* Load factor significantly impacts hash table performance.
* Open addressing with linear probing is space-efficient but sensitive to high load factors.  Performance approaches linear time as λ approaches 1.
* Chaining performs better at higher load factors but consumes more memory due to the linked lists.
* Binary search trees offer consistent logarithmic time complexity but require more storage than open addressing.
* The choice between open addressing and chaining depends on the specific application and the balance between performance and memory usage.  Open addressing is preferred when storage is a major concern.


### Key Takeaway

The size of the hash table and the collision handling technique are intertwined.  Careful consideration of the load factor and the expected number of comparisons is essential for designing an efficient hash table implementation. Rehashing is commonly employed to maintain a reasonable load factor and ensure constant time performance for open addressing.  When memory is at a premium, open addressing is a strong contender, but chaining offers more robust performance at the cost of increased storage requirements.
