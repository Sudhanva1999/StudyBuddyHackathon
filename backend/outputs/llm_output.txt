## CS5500: Foundations of Software Engineering - Detailed Lecture Notes

These notes provide a comprehensive overview of the CS5500: Foundations of Software Engineering course, encompassing key concepts, topics covered, technologies used, course policies, and assessment details.

### I. Introduction

This course aims to establish a strong foundation in software engineering principles and best practices.  The emphasis is on practical application, culminating in a team-based project where students develop a full-stack web application using a modern technology stack.  This hands-on approach solidifies theoretical concepts and provides valuable real-world experience.

### II. Course Objectives

Upon successful completion of this course, students should be proficient in:

*   Developing, managing, and maintaining software systems.
*   Eliciting, defining, documenting, and managing software requirements.
*   Collaborating effectively within a software development team.
*   Applying a formal software engineering process to full-stack development.

### III. Major Topics Covered

The course curriculum covers the following key areas of software engineering:

1.  **Software Processes:** This section explores various software development lifecycle models, their strengths, weaknesses, and applicability in different project contexts.
    *   **Models:** Waterfall, Incremental, Agile, and other relevant models will be discussed.
    *   **Applications:**  Understanding when to apply specific process models based on project characteristics and constraints.

2.  **Requirements Engineering:**  This module focuses on effectively gathering, analyzing, documenting, and managing software requirements.
    *   **Methods & Techniques:**  Formal and informal methods for eliciting requirements from stakeholders, managing changing requirements, and ensuring traceability.
    *   **Documentation:**  Best practices for documenting requirements clearly and unambiguously.

3.  **Software Architecture:** This section delves into the principles of sound software design and architectural patterns.
    *   **Architectural Patterns:**  Model-View-Controller (MVC), Singleton, Observer, and other common patterns.
    *   **Design Principles:** SOLID principles (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) and their application in building maintainable and extensible software.

4.  **System Modeling:**  This module introduces modeling tools and techniques to visually represent system behavior and structure.
    *   **UML (Unified Modeling Language):**  Using UML diagrams like Use Case Diagrams, Class Diagrams, and Sequence Diagrams to model different aspects of the system.
    *   **Modeling Tools:**  Hands-on experience with software tools that support UML and other modeling techniques.

5.  **Software Testing:** This section emphasizes the importance of testing throughout the software development lifecycle.
    *   **Test-Driven Development (TDD):**  Writing tests before writing the code, fostering a test-first approach.
    *   **Behavior-Driven Development (BDD):** Focusing on user behavior and defining acceptance criteria.
    *   **Testing Levels:**  Understanding and applying different testing levels, including unit testing, integration testing, system testing, and acceptance testing.

6.  **Software Maintenance & Evolution:**  This module addresses the ongoing process of maintaining and evolving software systems after deployment.
    *   **Continuous Integration and Continuous Delivery (CI/CD):** Automating the build, test, and deployment processes for faster and more reliable releases.
    *   **Version Control Systems:** Utilizing Git and understanding branching strategies for effective collaboration and code management.

7.  **Software Security:** This section covers essential security concepts and practices.
    *   **Threat Modeling:**  Identifying and mitigating potential security risks early in the development process.
    *   **Vulnerability Detection & Prevention:** Techniques to detect and prevent common software vulnerabilities.


### IV. Technology Stack

The course utilizes a modern and industry-relevant technology stack:

*   **Frontend:** TypeScript, React
*   **Backend:** Node.js, Express.js
*   **Database:** MongoDB

This stack provides a robust environment for full-stack web development. While the instructor will cover the stack's core concepts, students are expected to supplement their learning with independent study, particularly for TypeScript.  Using alternative stacks for the final project is permissible, but with limited support from course staff.

### V. Course Logistics

*   **Course Materials:** Canvas will be the central platform for accessing all course resources, including lecture slides, assignments, and announcements.
*   **Meeting Times:**  Refer to the course syllabus for specific meeting times and locations for each section. Both sections cover the same content.
*   **Recommended Textbooks:**  Several recommended textbooks delve deeper into specific topics, covering software engineering fundamentals, refactoring, UML, persistence, user stories, and value-sensitive design. Consult the syllabus for the complete list.


### VI. Communication & Collaboration

*   **Piazza:** The primary platform for all course-related discussions, questions, and announcements.  Avoid using Piazza for grade complaints or posting complete assignment solutions.  Refer to the syllabus for detailed Piazza etiquette.
*   **Email:**  Reserved for personal matters, scheduling appointments with instructors, and reporting technical issues with Canvas. Adhere to the email etiquette guidelines outlined in the syllabus.

### VII. Assessments and Grading

The course grade is determined by the following components:

*   **Exercises (10%):** In-class programming labs and discussion posts reinforcing lecture concepts.
*   **Assignments (45%):** Individual programming projects, software engineering activities, including two individual projects focused on the technology stack and different software architectures. Additional assignments cover system modeling, testing, and a group threat modeling exercise.
*   **Final Project (30% + 15% Presentation):**  A group project (groups of two) involving proposal submission, implementation, testing, project management plan, CI process, and a final presentation.
*   **Grading Scheme:** Specific assignment weights and grade cutoffs are detailed in the syllabus.


### VIII. Course Policies

*   **Late Policy:**  Exercises and individual assignments have a 48-hour grace period.  Group assignments cannot be submitted late.
*   **Re-grades:**  Submit re-grade requests via email within one week of receiving graded work.
*   **Academic Integrity:**  Plagiarism and other forms of academic dishonesty are not tolerated and will result in severe penalties.
*   **Generative AI Policy:** Permitted for individual and final projects, but prohibited for written assignments.
*   **Students with Disabilities:** Accommodations are available through Disability Access Services. Contact the instructor with relevant documentation.
*   **Inclusivity:** The course promotes a respectful and inclusive learning environment.  Share your preferred name and pronouns with the instructor.


### IX. Key Takeaways

This course provides a hands-on learning experience, emphasizing the practical application of software engineering principles using a modern technology stack. Active participation, collaboration, and adherence to course policies are essential for success.  Familiarize yourself with the technology stack early on, manage your time effectively, and leverage available resources like Piazza and office hours for assistance.
