{"transcript": {"text": "Everyone in this video, we will discuss the effect of the size we use for has table on his performance. So let me see. Are the slides to begin with? Again in our last class we discussed how can we handle when we have a collision using a stable with discuss two main ways? The first one being the open addressing with linear probing or be additional ways we can have to do the problem or the technique we discussed whether the pros and cons for each one of them, these three items that have heroes in our last class. These are the three decision choices. We have to think about everything with designing your horse stable. These three are all so interconnected with each other, right? So, the decision would take for one of these three topics here, affects how we handle the rest of the year decisions for these items here. So, are we going to use tanning or open a dressing for handling the collisions? The decision about what should be the size of the hospital we use? Are those going to be different based on the decision? Of course, everything depends on the function. That's, I would, I would discuss on the next video. Excuse me to the table, right? If we think about open addressing, we cannot have more elements in a stable than the actual size of the hashtag that were using. Because you never location yet again, which or each one of the elements of our data structure 14. In this is not the case, right? So if I have training again, I initialize my house table with a size, but might be a list of the actual value, something going to end up, starting in my data structure. What this means? Because I never look at some of the other day. I have linked lists, right? I can have a number of elements in there. So India that can have more value in my stable than the actual size of the table that I'm using. What are you coming to Performance of her stabilized, right? We saw winner last class. If we have open addressing, and the array gets pretty fool than the performance instead of constant running time, as we expect for the half stable, it gets closer to Union running time. So how can we make sure that we never get to give me a running time by controlling the load Factor below Factory? The greatest effect is the greatest impact about the performance of her stabilized, right? How is this Define is the number of elements that have stores in my data structure /? The table size house, you can imagine for open addressing this cannot be more than one, right? I cannot have more elements than the actual size of your day for open address for her. Stay with this in. They are with the teeming. However, this is not the case. So I can have more than one element in every element of weird because that is connected to Okay, so the first thing I want to show you, here is a Formula that is just an approximation. Now, this is what we're going to use for this discussion to hear our text book, has a more detailed probabilistic analysis that will give us than I expected. Number of comparisons when we perform a search operation in that has table, they didn't, they said it's a operation for tonight. In the does exist nor has table using open address in with you near problem. The formula I give you here is a bit more simplified and visit the drive-by. Do not know the weeds by many people is considered to be the father of the analysis of algorithms. So what you say is, right? This is that if I perform a search in a stable with open addressing in the Lowell Factory is f l. This is going to give me the expected number of combatants. I'm going to do so let's plug in a couple of oranges and see what is Formula says, rewrite you float, 530 side. Don't have any elements right then this fraction becomes one in the heaven. The balance is 1 + 12 / 214, right? I'm never going to have to do an additional problem of my a stable is empty. Of course, if the load Factor tends to one, you gave gets closer to 1. This gives us an infinitive I buy because Borderlands 2 Infinity. It's not real Infinity but the load Factor. We never really allowed me to get one in your life. No, for the changing things are a bit simpler, right? How many problems do I have to do for the shirts of an element Dino exist? I assume it exists in my house. That's the first thing I want to do. And actually let me go to the Whiteboard here. So let me stop sharing this one. Let me show you. On the Whiteboard. Perfect Painting. Looks like I missed. You have any size? Let's save this size has M elements. Or implication is this area, right. Every location of the array points to a linked list, If there's no elements here that would be just another voice. You hear. Otherwise, it's a different location. I have two elements that were mapped into this index on my house. They believe is our original English. I know the Lord is here, getting exceed one, right, because it, let's assume that everything here has two elements. If I have any locations in this has to do with changing. I would have to M elements total in my data structures. That would be 2 in that case. Now, again, if we are in an ideal scenario and we have a half function, that takes every value that they want to store it. In my accounts, payable includes a uniform, distribution of the values of the volume in Tuesday. Indexes of this has table, then I'm going to have any qualms number of elements in every link is here right now. So if my load Factor listen to, this is going to give me the average length of every linked list in here. And again, someone else might have three of them and someone, but the average is going to be two elements Pearl English, right? Okay. So if a performance artists, right? What is the expected number of comparisons, based on the load Factor, the first Pro Bowl, you always have to do? I asked him, I get my key. I get the house cold, and I find a index. The first probe is at taking the element in the table, does it point to an English door panel values? That's my first problem. And then an average, let's say I have my load factor to be 3, right? Or a successful search, you might be on the first second, or third element. So he fell, which is a low-fat also gives me again, as we discussed, the average length of a real English, do not resume had to scan half of my linked list, right? If I'm very like, it might be the head if I'm very unlike in might be via Taylor English, but whenever it's going to be somewhere in the middle. So what is the number of bodies on here? Is one for taking the initial location in the table, Plus The load Factor / do because the load Factor again, gives me the average length of every linked list on my heart's table. When we use 10 gear, Okay, so let me go back to the slides. So this is what we discuss here. This is for the Taney, right? So we have these two formulas. Now using these two formulas we can actually I have a table on the slides just to show you based on that load Factor. What is the performance of this wimp Lamentations? For handling collisions, right? Open addressing with linear problem, or Jamie? Of course if there has been Museum. Pillow Factory zero just one probe for every search operation if I have listened 90%, what this means if I have linear problem, 90% of the locations of the airport, even end up tonight. If you have it, it's or expected. Number of comparisons, for the search operation is five and a half, so it's not very bright. But again, as you see here for training This is just one approximately 1.5 service performed significantly better than the difference. Remember here, is that for linear problem. My house table limits. How many elements the size of my house that we miss, how many elements have been stored in my day. The structural, that's not the case for saying. There is no, so they load Factor can go to 2345 and more. That value would be the average length of a Lincoln still make a stable training. How does this compare with a binary search tree? We're going to discuss a lot more about binary search tree in our next class. However, logging operations for precipitation in assuming that the binary search tree is balanced, will discuss a lot more about it in the next two classes. But let's even for a small instance of a binary search tree with 120 and the elements. For example, I required 7 probes. Right. Which is more than any has table that has a 90% capacity. Insertion and removal in order to get those operation for her stable. Again, we expect constant running time of operations, but if we have, let's see a stable with open address in, in, in your probing and we get to 99% for the worse case becomes fully near here. This would be if we can get this work today, to perform binary search? That would be big or offend or insult an element with correct position and binary search tree log in again if it's not balanced however, he can get to you near us. No, it looks like the last a militant before a lot better, right. So why would we ever consider using D in their problem? The answer is the storage requirements, right? So we so hard that has to be size affect their performance, in in reality, right? When we use after, what do we want to do? We want to make sure if we use the meaning of probing specifically. If we exceed the specific load Factor, let's eighty-five 90% of the size to New Era, Ray rehash of the values and use it be. Getting some severe are always make sure that the situation is going to be performed in constant running. Time is not linear. So for the storage requirements, the performance of passing is superior, of course to buy Addison trees, articular leave. The other factor is less than 75%. And also the difference increases with the size of the data structure, for the binary search tree is not affected, really, for how many values I store from my house Stables, as long as I maintain good load Factor. A binary said, she remembered requires for references burnout, the actual value reference to partying left, and right to drink. Some. More storage is required for the binary sentries, and that open house table with litsey 75% capacity. So, just to give you an example here, right? For open addressing things are very simple if I have The number of references buy items is an assumed that we have a full array. In reality is going to be in /. The load factor to get their first day. Besides how many difference is I need the memory 14 in galvanized number of nodes in a list is alright? The load Factor as we discussed earlier and is the number of Terry table element using add a linked list. There will be three references, he needs to know the item next and previews as we discussed in one of our last class, is using a singly linked list will induce a number of references by one. So, the total storage and this is right. For the first day that has, they linked to each one of the link. Lisa Wu have been for that size. And then + 2 x + x, + 4, because of whatever you again, for every one of the values of the heaven, my data structure different Heaven by use. I need two differences and then Ellie is the expected length of each linked list, right? So at this point, I'm going to give you a small exercise. So let's assume that we use open addressing with you in your probing. And let's say, I want to have $60,000 in my house there. If I want to maintain, let's see you whenever it's 2.5 comparisons and no tomorrow, right? If I go back to this light where I showed, you this 102.5 comparisons with a 75% loan Factory 0.75. So, if I go back here, so if let's say, I want to start 60,000 by using a open addressing a linear problem, I want to have 2.5 comparisons that would give me 0.75 for the load factor. And this will give me the size of the last day before the pan of dressing with me to be eighty thousand Brighton. I want you to think about the question. Now, what would be the size of a stable was saying if I wanted to have the same performance, right? So 2.5 comparison, average. And again, keep in mind for this question but this is the number of comparisons, will we get on the stable Cheney, right? So if I do not have C 2.5, what is the load Factor? So you can post that we do here and think about what would be the size of a hash table with training to get the same performance, right? Suppose the video thing about this question resume when you've helped solve the equation? Okay, so now I want to show you the answer to this one, right? So if we have a can opener dressing with 60,000 items in the house table, we need to load factor of 0.75 / 42.5 comparisons. This results in 90,000 for the size of the house table with a pan of dressing, a linear problem or the same size, or for the same performance. If I want to have changing write 2.5 as a show you the formula before 1 + 8, / 2. So you are, you find X everything with two. I get here and then I subtract 2 from both sides. Remember, what is the load Factor, right? Is 60000 / the size of my heart stable, so that So does that mean that they need less space or getting better performance in Las Vegas? Retaining is not the case here again, let's pause here for a minute and think about this question, right? Do I need less space for her Stables? Open addressing, in Cheney Okay, if you felt about this question, let me actually found that for has table with painting, me twenty thousand for the size of the house. Able to let me go back to the board and I believe the head of steam what they do before on the board. Perfect. Yes. So what did we find? Here we found the size of this has table, right? So this is going to be 20,000 here. So, Ulysses, 20,000 write. This means that for 20,000 elements desert dust references to linked list. I have a total of 60000, right? So let me get my pain here to have a total of 60000 values. V, 60,000 Mi I need to turn in my stable, is there going to be stored in elements in all of these linked list in my house table Cheney? Right? For every other Monday fire somehow use singly linked list for every element. I need the value in the reference to the next show. For each one of the 60,000 elements old is linked list. I need the hundred and twenty thousand references to the memory. Plus the $20,000 for the actual has to be here. So that would give me a total of 140000, right, 140k, references to the memory for this folder presentation of the first debuted in because I have the table and then I have that all of them will have this $60,000 this year. I remember Let me see the presentation. I don't have any value storage here. So the actual has told me just as the reference is to the actual link is here. Okay, so let me go out to the slides. So the following this analysis here again, 140,000 would be for a stable, with chaining if I wanted the same performance, right? He was only 80,000 ft open the dressing with linear programming. So changing has its own benefits performs better, but it does require more storage than the open addressing with linear problem. So if storage is an issue in those cases, we use open addressing with you near problem. We listen, I'm going to stop here in the next video. I'm going to discuss about the house functions. We can use to mop a value into an index in the house tape. Thank you.", "confidence": 0.9470080648582254}, "summary": "there is no, so they load Factor can go to 2345 and more. if I perform a search in a stable with open addressing in the Lowell Factory is f l. this is going to give me the expected number of combatants.", "notes": "## Hash Table Performance: Size and Collision Handling\n\n### Introduction\n\nThis lecture explores the impact of hash table size on performance, focusing on collision handling techniques. We'll revisit open addressing with linear probing and chaining, analyzing their performance characteristics and trade-offs.  The lecture also touches upon the relationship between these techniques and the choice of hash function (covered in the next lecture).  Finally, we'll compare hash table performance with binary search trees, highlighting the strengths and weaknesses of each data structure.\n\n### Key Concepts\n\n* **Collision Handling:** When two or more keys hash to the same index in a hash table, a collision occurs. Two primary methods for resolving collisions are:\n\n    * **Open Addressing (Linear Probing):**  If a collision occurs, the algorithm probes the next available slot in the hash table (using a linear increment). This continues until an empty slot is found.\n\n    * **Chaining (Separate Chaining):** Each index in the hash table points to a linked list (or other data structure).  All keys hashing to the same index are stored in that list.\n\n* **Load Factor (\u03bb):**  A critical metric for hash table performance. It is defined as:\n\n    \u03bb = Number of elements in the hash table / Size of the hash table\n\n    * For open addressing, \u03bb cannot exceed 1.\n    * For chaining, \u03bb can be greater than 1.\n\n* **Expected Number of Comparisons:** The average number of probes (or comparisons) needed to find an element (or determine its absence) in the hash table.  This is directly affected by the load factor.\n\n### Performance Analysis\n\n* **Open Addressing (Linear Probing):**\n\n    * As the load factor approaches 1, performance degrades significantly.  The expected number of comparisons approaches linear time (O(n)).\n    * An approximate formula for the expected number of comparisons for a successful search is:\n\n        (1 + 1 / (1 - \u03bb)) / 2\n\n* **Chaining (Separate Chaining):**\n\n    * Performance is less sensitive to a high load factor compared to open addressing.\n    * The expected number of comparisons for a successful search is approximately:\n\n        1 + \u03bb / 2\n\n    *  This assumes a uniform distribution of keys across the hash table indices.\n\n* **Comparison Table (Approximate Values):**\n\n| Load Factor (\u03bb) | Open Addressing (Expected Comparisons) | Chaining (Expected Comparisons) |\n|---|---|---|\n| 0 | 1 | 1 |\n| 0.5 | 1.5 | 1.25 |\n| 0.75 | 2.5 | 1.375 |\n| 0.9 | 5.5 | 1.45 |\n| \u2192 1 | \u2192 \u221e | \u2192 1 + \u03bb/2 |\n\n* **Comparison with Binary Search Trees:**\n\n    * Balanced binary search trees offer logarithmic time complexity (O(log n)) for search, insertion, and deletion.\n    * Hash tables with a good load factor can outperform binary search trees, especially for smaller datasets.  However, as the load factor increases in open addressing, hash table performance degrades.\n    * Binary search trees require more storage due to pointers/references for left and right children (and potentially a parent node).  Open addressing with linear probing is more space-efficient when the load factor is reasonable. Chaining requires additional space for the linked lists, impacting its space efficiency compared to open addressing.\n\n\n### Example and Exercise\n\n* **Scenario:**  Store 60,000 items and maintain an average of 2.5 comparisons per search.\n\n* **Open Addressing (Linear Probing):**\n\n    * To achieve 2.5 comparisons, the load factor should be approximately 0.75.\n    * Hash Table Size = 60,000 / 0.75 = 80,000\n\n* **Chaining (Separate Chaining):**\n\n    * To achieve 2.5 comparisons:\n\n        2.5 = 1 + \u03bb / 2\n        \u03bb = 3\n\n    * Hash Table Size = 60,000 / 3 = 20,000 (initial array size)\n\n* **Storage Comparison:** While chaining appears to require a smaller hash table, it actually uses more memory overall.\n\n    * **Open Addressing:** 80,000 references (approximately).\n    * **Chaining:**  20,000 references for the hash table + (60,000 * 2) = 120,000 references for the linked list elements (assuming singly linked lists, requiring one \"next\" pointer) = 140,000 total references.\n\n\n### Summary\n\n* Load factor significantly impacts hash table performance.\n* Open addressing with linear probing is space-efficient but sensitive to high load factors.  Performance approaches linear time as \u03bb approaches 1.\n* Chaining performs better at higher load factors but consumes more memory due to the linked lists.\n* Binary search trees offer consistent logarithmic time complexity but require more storage than open addressing.\n* The choice between open addressing and chaining depends on the specific application and the balance between performance and memory usage.  Open addressing is preferred when storage is a major concern.\n\n\n### Key Takeaway\n\nThe size of the hash table and the collision handling technique are intertwined.  Careful consideration of the load factor and the expected number of comparisons is essential for designing an efficient hash table implementation. Rehashing is commonly employed to maintain a reasonable load factor and ensure constant time performance for open addressing.  When memory is at a premium, open addressing is a strong contender, but chaining offers more robust performance at the cost of increased storage requirements.\n", "flashcards": [{"question": "What are the three interconnected decisions to consider when designing a hash table?", "answer": "1. Collision handling method (chaining or open addressing), 2. Hash table size, 3. Hash function."}, {"question": "What is a key difference between open addressing and chaining regarding table size and number of elements?", "answer": "In open addressing, the number of elements cannot exceed table size.  Chaining allows more elements than the table size."}, {"question": "What is the load factor and how does it impact hash table performance?", "answer": "Load factor = (number of elements) / (table size).  A higher load factor generally degrades performance, especially with open addressing."}, {"question": "What are the approximate average search comparison formulas for open addressing and chaining?", "answer": "Open addressing: (1 + 1 / (1 - load_factor)) / 2.  Chaining: 1 + (load_factor / 2)."}, {"question": "Why might open addressing be preferred over chaining despite potentially worse performance?", "answer": "Open addressing requires less storage space than chaining."}, {"question": "What is rehashing and why is it used in open addressing?", "answer": "Rehashing involves resizing the hash table and redistributing elements to maintain a lower load factor and improve performance."}, {"question": "In the example, why does chaining require more storage than open addressing for the same performance?", "answer": "Chaining needs to store pointers for linked lists, increasing memory usage compared to open addressing's contiguous storage."}], "mindmap": {"topic": "Hash Table Performance", "branches": [{"name": "Collision Handling", "type": "method", "subbranches": [{"name": "Open Addressing", "description": "Linear probing, limited by table size"}, {"name": "Chaining", "description": "Linked lists, can exceed table size"}]}, {"name": "Load Factor", "type": "concept", "subbranches": [{"name": "Definition", "description": "Number of elements / Table size"}, {"name": "Impact", "description": "Greatest effect on performance"}, {"name": "Open Addressing Limit", "description": "Cannot exceed 1"}]}, {"name": "Performance Analysis", "type": "concept", "subbranches": [{"name": "Open Addressing", "description": "Approaches linear time as load factor nears 1"}, {"name": "Chaining", "description": "Affected by average linked list length"}, {"name": "Comparison with BST", "description": "Hash tables generally faster with good load factor"}]}, {"name": "Storage Requirements", "type": "concept", "subbranches": [{"name": "Open Addressing", "description": "Directly proportional to table size"}, {"name": "Chaining", "description": "Includes table and linked list references"}, {"name": "Comparison with BST", "description": "Open addressing can be more space-efficient"}]}, {"name": "Rehashing", "type": "method", "subbranches": [{"name": "Purpose", "description": "Maintain constant time performance"}, {"name": "Trigger", "description": "Load factor exceeding threshold"}]}]}}